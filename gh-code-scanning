#!/usr/bin/env python

import argparse
import json
import os
import random
import shutil
import string
import subprocess
import sys
import tempfile

def get_default_branch(gh, nwo):
    cmd = subprocess.run([gh, 'api', f'repos/{nwo}'], capture_output=True)
    return json.loads(cmd.stdout)['default_branch']

def get_codeql_langs(gh, nwo):
    """
    Obtain the programming languages that GitHub detected in the repo nwo.
    Then, filter the languages down to the CodeQL supported languages, and
    transform them to the CodeQL language identifiers.
    """
    cmd = subprocess.run([gh, 'api', f'repos/{nwo}/languages'], capture_output=True)
    for lang in json.loads(cmd.stdout):
        if lang in ['C', 'C++']:
            yield 'cpp'
        elif lang == 'Java':
            yield 'java'
        elif lang == 'C#':
            yield 'csharp'
        elif lang == 'Go':
            yield 'go'
        elif lang == 'Python':
            yield 'python'
        elif lang in ['JavaScript', 'TypeScript']:
            yield 'javascript'

def random_weekly_cron_expr():
    return '{} {} * {} {}'.format(
        random.randint(0, 59), # minute
        random.randint(0, 23), # hour
        random.randint(1, 12), # month
        random.randint(0, 6)   # day of week
    )

# json_multiloads decodes multiple JSON documents that have
# been concatenated together, as `gh api --paginate` does.
# See: https://github.com/cli/cli/issues/1268.
def json_multiloads(json_string, spool=[]):
    try:
        spool += json.loads(json_string)
    except json.decoder.JSONDecodeError as e:
        spool += json.loads(json_string[:e.pos])
        json_multiloads(json_string[e.pos:], spool)
    return spool

def get_parent_exe():
    try:
        ps = subprocess.run(['ps', '-oargs=', '-p', str(os.getppid())], capture_output=True, check=True)
        return ps.stdout.decode('UTF-8').split()[0]
    except subprocess.CalledProcessError:
        return None

def enable(args):
    with open(os.path.join(os.path.dirname(__file__), 'codeql-analysis.yml')) as f:
        workflow_template = string.Template(f.read())

    branch_name = 'gh-code-scanning_{}/enable'.format(os.getpid())

    for nwo in args.repos:
        os.chdir('/')
        with tempfile.TemporaryDirectory('gh_code_scanning') as temp_dir:
            command = [args.gh, 'repo', 'clone', nwo, temp_dir, '--', '--depth=1']
            if not args.verbose:
                command.append('--quiet')
            subprocess.run(command)
            
            os.chdir(temp_dir)

            if os.path.exists('.github/workflows/codeql-analysis.yml') and not args.force:
                printf('error: ".github/workflows/codeql-analysis.yml" already exists; skipping...', file=sys.stderr)
                continue
            
            command = [args.git, 'checkout', '-b', branch_name]
            if not args.verbose:
                command.append('--quiet')
            subprocess.run(command)

            try:
                os.mkdir('.github')
                os.mkdir('.github/workflows')
            except FileExistsError as e:
                pass

            workflow_contents = workflow_template.safe_substitute(
                DEFAULT_BRANCH_EXPR=repr([ get_default_branch(args.gh, nwo) ]),
                SCHEDULE_CRON_EXPR=repr(random_weekly_cron_expr()),
                MATRIX_LANGUAGE_EXPR=repr(list(get_codeql_langs(args.gh, nwo)))
            )

            with open('.github/workflows/codeql-analysis.yml', 'w') as f:
                f.write(workflow_contents)
            
            subprocess.run([args.git, 'add', '--all'])
            
            command = [args.git, 'commit', '--message', 'Create .github/workflows/codeql-analysis.yml']
            if not args.verbose:
                command.append('--quiet')
            subprocess.run(command)
            
            command = [args.git, 'push', '--set-upstream', 'origin', branch_name]
            if not args.verbose:
                command.append('--quiet')
            subprocess.run(command)
            
            subprocess.run([args.gh, 'pr', 'create', '--fill', '--head', branch_name])

def alerts(args):
    for nwo in args.repos:
        command = [args.gh, 'api', '--paginate', f'repos/{nwo}/code-scanning/alerts']
        try:
            gh = subprocess.run(command, capture_output=True, check=True)
        except subprocess.CalledProcessError as e:
            print(f'error: {nwo}: {e.stderr}', file=sys.stderr)
            continue

        for alert in json_multiloads(gh.stdout):
            print(nwo,
                  format(alert['number'], '>4d'),
                  alert['created_at'],
                  alert['state'],
                  alert['rule']['id'],
                  '{}:{}'.format(alert['most_recent_instance']['location']['path'], alert['most_recent_instance']['location']['start_line'])
            )
            
def main():
    gh_exe = get_parent_exe() or shutil.which('gh')
    if gh_exe is None:
        printf('error: cannot find `gh` executable; please specify a path with `--gh`.', file=sys.stderr)
        exit(1)

    git_exe = shutil.which('git')
    if git_exe is None:
        print('error: cannot find `git` executable; please specify a path with `--git`.', file=sys.stderr)
        exit(1)
    
    parser = argparse.ArgumentParser()
    parser.add_argument('--gh', metavar='path', default=gh_exe, help='path to the gh executable.')
    parser.add_argument('--git', metavar='path', default=git_exe, help='path to the git executable.')
    parser.add_argument('-v', '--verbose', action='store_true', help='print diagnostic information.')
    parser.set_defaults(func=lambda x: parser.print_help())
    subparsers = parser.add_subparsers()
    
    parser_enable = subparsers.add_parser('enable', help='set up Code Scanning with GitHub CodeQL.')
    parser_enable.add_argument('-f', '--force', action='store_true', help='overwrite existing workflow file.')
    parser_enable.add_argument('repos', nargs='+')
    parser_enable.set_defaults(func=enable)
    
    parser_alerts = subparsers.add_parser('alerts', help='download code-scanning alerts.')
    parser_alerts.add_argument('repos', nargs='+')
    parser_alerts.set_defaults(func=alerts)
    
    args = parser.parse_args()
    args.func(args)

if __name__ == '__main__':
    main()
