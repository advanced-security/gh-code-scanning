#!/usr/bin/env python
"""A GitHub CLI extension for interacting with GitHub Code-Scanning."""

import argparse
import os
import shutil
import string
import subprocess
import sys
import tempfile
import utils

def enable(args):
    """
    `enable()` sets up CodeQL for a repository by adding a GitHub-Actions workflow to that repository.
    """
    output = None if args.verbose else subprocess.DEVNULL
    branch_name = 'mario-campos/gh-code-scanning'
    workflow_name = 'codeql-analysis.yml'
    workflow_dstdir = '.github/workflows'
    workflow_srcpath = os.path.join(os.path.dirname(__file__), workflow_name)
    workflow_dstpath = os.path.join(workflow_dstdir, workflow_name)

    with open(workflow_srcpath) as f:
        workflow_template = string.Template(f.read())

    for nwo in args.repos:
        os.chdir('/')
        with tempfile.TemporaryDirectory() as temp_dir:
            subprocess.run([args.gh, 'repo', 'clone', nwo, temp_dir, '--', '--depth=1'], stdout=output, stderr=output)
            
            os.chdir(temp_dir)

            if os.path.exists(workflow_dstpath) and not args.force:
                print(f'error: {nwo}: workflow "{workflow_name}" already exists.', file=sys.stderr)
                continue

            repo_langs = utils.github.get_repo_langs(args.gh, nwo)
            if utils.codeql.languages.isdisjoint(repo_langs):
                print(f'error: {nwo}: no supported programming languages.', file=sys.stderr)
                continue
            
            if not args.git_push:
                subprocess.run([args.git, 'checkout', '-b', branch_name], stdout=output, stderr=output)

            workflow_contents = workflow_template.safe_substitute(
                DEFAULT_BRANCH_EXPR=repr(utils.github.get_repo_default_branch(args.gh, nwo)),
                SCHEDULE_CRON_EXPR=repr(utils.actions.random_weekly_cron_expr()),
                MATRIX_LANGUAGE_EXPR=repr(list(map(utils.codeql.normalize_lang, utils.codeql.languages.intersection(repo_langs))))
            )

            os.makedirs(workflow_dstdir, exist_ok=True)
            with open(workflow_dstpath, 'w') as f:
                f.write(workflow_contents)
            
            subprocess.run([args.git, 'add', '--all'], stdout=output, stderr=output)
            subprocess.run([args.git, 'commit', '--message', f'Create {workflow_dstpath}'], stdout=output, stderr=output)

            if args.git_push:
                subprocess.run([args.git, 'push', 'origin', utils.github.get_repo_default_branch(args.gh, nwo)], stdout=output, stderr=output)
            else:
                subprocess.run([args.git, 'push', '--set-upstream', 'origin', branch_name], stdout=output, stderr=output)
                subprocess.run([args.gh, 'pr', 'create', '--fill', '--head', branch_name], stdout=output, stderr=output)

def alerts(args):
    """
    `alerts()` prints the Code-Scanning alerts of a GitHub repository to STDOUT.
    """
    for nwo in args.repos:
        try:
            alerts = utils.github.get_repo_cs_alerts(args.gh, nwo)
        except subprocess.CalledProcessError as e:
            message = e.stderr.decode('UTF-8').strip()
            print(f'error: {nwo}: {message}', file=sys.stderr)
            continue
        for alert in alerts:
            print(nwo,
                  format(alert['number'], '>4d'),
                  alert['created_at'],
                  format(alert['state'], '>9s'),
                  alert['rule']['id'],
                  '{}:{}'.format(alert['most_recent_instance']['location']['path'], alert['most_recent_instance']['location']['start_line'])
            )
            
def main():
    """
    `main()` parses the command-line arguments and dispatches to the appropriate function.
    """
    gh_exe = utils.misc.get_parent_exe() or shutil.which('gh')
    if gh_exe is None:
        sys.exit('error: cannot find `gh` executable; please specify a path with `--gh`.')

    git_exe = shutil.which('git')
    if git_exe is None:
        sys.exit('error: cannot find `git` executable; please specify a path with `--git`.')
    
    parser = argparse.ArgumentParser()
    parser.add_argument('--gh', metavar='path', default=gh_exe, help='path to the gh executable.')
    parser.add_argument('--git', metavar='path', default=git_exe, help='path to the git executable.')
    parser.add_argument('-v', '--verbose', action='store_true', help='print diagnostic information.')
    parser.set_defaults(func=lambda x: parser.print_help())
    subparsers = parser.add_subparsers()
    
    parser_enable = subparsers.add_parser('enable', help='set up Code Scanning with GitHub CodeQL.')
    parser_enable.add_argument('-f', '--force', action='store_true', help='overwrite existing workflow file.')
    parser_enable.add_argument('--git-push', action='store_true', help='do not create PR; push commit to HEAD of default branch.')
    parser_enable.add_argument('repos', nargs='+')
    parser_enable.set_defaults(func=enable)
    
    parser_alerts = subparsers.add_parser('alerts', help='download code-scanning alerts.')
    parser_alerts.add_argument('repos', nargs='+')
    parser_alerts.set_defaults(func=alerts)
    
    args = parser.parse_args()
    args.func(args)

if __name__ == '__main__':
    main()
